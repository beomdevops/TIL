"""
11053 가장 긴 증가하는 부분 수열 

 A = {10, 20, 10, 30, 20, 50}인경우 10,20,30,50이며 길이는 4이다.

 arr = [10,20,10,30,20,50]
 dp  = [1, 1, 1, 1, 1, 1]

 idx = 0, arr[0] = 10 보다 작은 내앞의 arr의 수를 카운트한다. 하지만 현재 10보다 작은 수는 없으므로 증가하는 수열은  자기자신
 을 포함한 dp[0] = 1이 된다.

 idx = 1, arr[1] = 20 보다 작은 내앞의 arr수 카운트 arr[1] 보다 작은 정수배열 요소는 arr[0]이다. dp[0]의 값 +1 해주면  증가하는 수열은 
 dp[1] = 2가 된다.
 
 idx = 2, arr[2] = 10 보다 작은 수를 카운트. 없으므로 증가하는 수열은 자기자신을 포함한 
 dp[2] = 1이 된다.

 idx =3 , arr[3] == 30 보다 작은 수를 카운트, arr[0] =10 , arr[1] =20 이 있고 dp[0] =1, dp[1] = 2 최대값인 dp[1] +1 해준값으로 갱신한다.  
 dp[3] = 3이 된다.

 idx = 4, arr[4] == 20 보다 작은 수 카운트, arr[0], arr[2]  증가하는 수열은 dp[0] = 1, dp[2] = 1이므로 최대값에 +1 해주며 dp를 갱신한다.
 dp[4] = 2가 된다.

 idx = 5, arr[5] == 50 보다 작은 수 카운트, arr[0], arr[1], arr[2], arr[3], arr[4]이며 최대값응 dp[3] = 3에 +1 을 해주어 dp를 갱신
 dp[5] = 4가 된다.
 
"""


x = int(input())

arr = list(map(int, input().split()))

dp = [1 for i in range(x)]

for i in range(x):
    for j in range(i):
        if arr[i] > arr[j]:
            dp[i] = max(dp[i], dp[j]+1)

print(max(dp))


