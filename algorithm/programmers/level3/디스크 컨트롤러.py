import heapq
"""
프로그래머스 level3 디스크 컨트롤러
input = 각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs
Ouput = 작업의 요청부터 종료까지 걸린 시간의 평균(최소치)

Constraints
- jobs의 길이는 1 이상 500 이하입니다.
- jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.
- 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.
- 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.
- 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.

DS - 힙 큐(여러 값 중 미니멈 값 찾아서 계산하기 위해)

1. 현재시점 time을 0으로 초기화하고 현재 시점에서 작업이 있으면 해당 작업을 heap에 주어진 job을 반대로 ex[0,3] -> [3,0]식으로 저장한다.(최소 시간이 걸린 작업 먼저 수행하기 위해)
2. 작업이 있을 경우 len(heap) > 0 즉 힙이 비어있지 않을 경우 힙에서 하나를 꺼내 작업을 수행한다. 이때 현재 진행한 작업을 수행하지 않기 위해 start라는 변수를 두어 start에 현재 시간을 저장해준다. 이후 time에 작업까지 걸린 시간을 더해준다.  요청에서 종료까지 시간 계산을 ret배열에 넣어준다.
3. 작업이 없을 경우 현재 시간에서 +1(시간을 증가시켜준다)
4. 반복문을 잡을 개수만큼 돌려준다.
5. ret배열의 합을 잡을 개수만큼 나누어주면 정답이된다.

time = O(n*j)



## 고민
힙을 어떻게 사용해야할지 고민했다. 처음 시도했을때는 감이 전혀 잡히지 않았다. 어떻게 힙을 사용하지? 라는 고민하다가 1시간 정도 고민해도 답이 보이지 않았다.. 어떤 분의 블로그 글을 보니 힙을 완료한 시점에서 수행할 수 있는 작업 들을 힙에다 저장하는것 이었다.. 바로 깨달았다.. 계속 고민하던게 여기서 풀렸다. 주어진 테스트케이스에서 A를 완료하고 B,C를 작업 할 수 있는데 어떻게 하면 C를 먼저 작업할지 고민 했다... 작업 한 조건문에서 heap에 값을 푸쉬해 주니 완성 할 수 있었다.. 할 수 있을 것 같았는데 저 생각을 못하다니... 아직 경험치와 학습이 부족한 것 같다..

"""
def solution(jobs):
    answer = 0
    heap = []
    time = 0
    ret = []
    start = -1
    cnt = 0
    while cnt < len(jobs):
        #현재 처리할 수 있는 작업 저장
        # 해당 테스트 케이스에서 A의 작업이 끝나면 time = 3이다
        # 시간이 3에서 B,C 작업 중 최소 작업 시간을 선택해야 하므로
        # 힙에 작업시간을 넣어주면 pop시 작은 순서를 가져온다.(이걸 생각 못했다..)
        for i in range(len(jobs)):
            if time >= jobs[i][0] > start:
                heapq.heappush(heap,[jobs[i][1],jobs[i][0]])
        if len(heap) > 0: # 작업할게 있다면  
            curTime = heapq.heappop(heap)
            start = time
            time += curTime[0]
            ret.append(time - curTime[1]) # 요청에서 종료까지 시간 계산
            cnt+=1
        else: #작업 없으면 다음시간으로 
            time+=1

    return sum(ret)//len(jobs)
    
