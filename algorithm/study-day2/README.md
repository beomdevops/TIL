## 알고리즘 스터디 2차시 이분탐색

로그

- 로그값은 괴장히 천천히 증가한다
- 알고리즘의 시간복잡도에 로그를 붙인다면??
  - 알고리즘의 수행 시간이 log(데이터 크기)에 비례한다??
좋은 알고리즘



이분 탐색

- 탐색알리즘: 무엇가를 찾는 알고리즘
  - 특정한원소, 조건에 맞는 경우, 최적의 값


배열에서 어던 값을찾을 때
 - 완전탐색: 모든 원소를 하나씩 살펴봄

 vs

 - 이분 탐색 : (정렬되어 있다면)각 단계마다 고려해야 하는 원소를 반씩 줄임



이분 탐색의 조건 & 시간복잡도

- 데이터가 어떻게든 정렬되어 있어야한다

- 시간복잡도
  -  하나의 후보만 남을 때까지 정답 후보를 반으로 줄이는 횟수
  -  O(log2 N)



[s,e 구간에 대해 탐색 수행]

두 스타일 중 하나를 정하고

s <= e / e = mid - 1 등의 코드를 외우는게 편하다.

잘못짜면 루한 루프에서 헤어나올수 없음


Parametric search(매개 변수 탐색)

- 이분 탐색처럼 정답의 후보를 반씩 줄여다낙며 최적의 정답을 찾는다
 - 완전탐색보다 훠린 빠르다

- 최적화 문제에 사용


- 이분 탐색을 쓰고싶어요 => 데이터가 정렬되어있어야함

- lower_bound, upper_bound (파이썬에는 bisect 모듈에는 bisect_right와, bisect_left가 있습니다. 쉽게 말해서 이 둘은 정렬된 list에서 upper_bound와 lower_bound)
 - 해당 값을 가리키는 위치 or 이터레이터 반환
 - 사용법 
   - 정렬된 배열의 인덱스 = bisect_left(정렬된 배열, 찾을 값)
   - ex) 숫자카드2(주어진 수가 몇개있는지) - 파이썬
   
            idx1 = bisect_left( n개의 정렬된 배열, 찾을 값)
            idx2 = bisect_right( n개의 정렬된 배열, 찾을 값)


   - ex) 숫자카드2 문제      -     C++

            idx1 = loser_bound(num, num+n, now) - num;
            idx 2  = uper_bound(num,num+n, now) - num;

            count = idx2 - idx1
            1 2 3 3 3 3 4 ...



Parametric search 활용
 - 입력 범위가 터무니 없이 클 때
 - 다른 풀이 생각나지 않을 때
  - 정답 후보들에게 단조성을 줄 수 있는 질문이 있는지



