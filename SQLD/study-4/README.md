## ```SQL 기본```

```순수 관계 연산자```
-  관계형 DB를 새롭게 구현

        1. SELECT -> WHERE
        2. PROJECT -> SELECT
        3. NATRUAL JOIN -> 다양한 JOIN
        4. DIVIDE -> 사용x
        {a,x}{a,y}{a,z} divdie {x,z} = {a}

### ```FROM 절 JOIN 형태```

    1. INNER JOIN

    2. NATURAL JOIN

    3. USING 조건절

    4. ON 조건절

    5. CROSS JOIN

    6. OUTER JOIN


### ```INNER JOIN```
- JOIN 조건에서 동일한 값이 있는 행만 
반환, USING이나 ON 절을 필수적으로 사용


### ```NATURAL JOIN``` 
- 두 테이블 간의 동일한 이름을 갖
는 모든 칼럼들에 대해 EQUI JOIN 수행, NATURAL 
JOIN이 명시되면 추가로 USING, ON, WHERE 절에
서 JOIN 조건을 정의할 수 없다, SQL Sever는 지원x

### ```USING 조건절```
- 같은 이름을 가진 칼럼들 중에서 원하는 칼럼에 대해
서만 선택적으로 EQUI JOIN을 할 수 있다, JOIN 칼
럼에 대해서 ALIAS나 테이블 이름과 같은 접두사를 
붙일 수 없다, SQL Server 지원x


### ```ON 조건절```
- ON 조건절과 WHERE 조건절을 분리하여 이해가 쉬
우며, 칼럼명이 다르더라도 JOIN 조건을 사용할 수 있
는 장점이 있다, ALIAS나 테이블명 반드시 사용

### ```CROSS JOIN```
- 양쪽 집합의 M*N건의 데이터 조합이 발생한다. OUTER JOIN
JOIN 조건에서 동일한 값이 없는 행도 반환 가능하다, USING이나 ON 조건절 반드시 사용해야 함

### ```LEFT OUTER JOIN```
- 조인 수행시 먼저 표기된 좌측 테이블에 해당하는 데
이터를 읽은 후, 나중 표기된 우측 테이블에서 JOIN 
대상 데이터를 읽어 온다. 우측 값에서 같은 값이 없
는 경우 NULL 값으로 채운다. 

### ```RIGHT OUTER JOIN```
- LEFT OUTER JOIN의 반대
FULL OUTER JOIN
조인 수행시 좌측, 우측 테이블의 모든 데이터를 읽어 
JOIN하여 결과를 생성한다. 중복 데이터는 삭제한다. 


### ```계층형 질의``` 
- 테이블에 계층형 데이터가 존재하는 경
우 데이터를 조회하기 위해 사용


### ```SATRT WITH```
- 계층 구조 전개의 시작 위치 지정


### ```CONNECT BY```
 - 다음에 전개될 자식 데이터 지정

### ```PRIOR``` 
 - CONNECT BY 절에 사용되며, 현재 읽은 
칼럼을 지정한다. 
 - PRIOR 자식 = 부모 형태를 사용하
면 계층구조에서 부모 데이터에서 자식 데이터(부모->
자식) 방향으로 전개하는 순방향 전개를 한다. 
- 반대는 역방향 전개

### ```NOCYCLE```
 - 동일한 데이터가 전개되지 않음
### ```ORDER SIBLINGS BY``` 
 - 형제 노드간의 정렬 수행

### ```WHERE``` 
 - 모든 전개를 수행한 후에 지정된 조건을 
만족하는 데이터만 추출한다.(필터링)

### ```LEVEL``` :
 - 루트 데이터이면 1, 그 하위 데이터면 2, 리프 데이터까지 1씩 증가

### ```CONNECT_BY_ISLEAF```
 - 해당 데이터가 리프 데이터면1, 그렇지 않으면 0


### ```CONNECT_BY_ISCYCLE``` 
 - 해당 데이터가 조상이면 1, 아니면 0 (CYCLE 옵션 사용했을 시만 사용 가능)

### ```SYS_CONNECT_BY_PATH``` 
 - 루트 데이터부터 현재 전개할 데이터까지의 경로를 표시한다. 
 
### ```CONNECT_BY_ROOT``` 
 - 현재 전개할 데이터의 루트 데이터를 표시한다. 
 - 단항 연산자이다. 


### ```셀프 조인``` 
 - 동일 테이블 사이의 조인, FROM 절에 
동일 테이블이 2번 이상 나타난다. 반드시 테이블 별칭을 사용해야 함


### ```서브 쿼리``` 
 - 하나의 SQL문안에 포함되어 있는 또 다
른 SQL문, 알려지지 않은 기준을 이용한 검색에 사용


### ```서브 쿼리 사용시 주의 사항```

    1. 서브쿼리를 괄호로 감싸서 사용한다. 

    2. 서브쿼리는 단일 행 또는 복수 행 비교 연산자와 함께 사용 가능하다. 단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하여야 하고 복수 행 비교 연산자는 결과 건수와 상관없다. 

    3. 서브쿼리에서는 ORDER BY를 사용하지 못한다. 

    4. SELECT, FROM, WHERE, HAVING, ORDER BY, INSERT-VALUES, UPDATE-SET 절에 사용 가능

- 단일 행 비교 연산자 : =,<,>,<> 등
- 다중 행 비교 연산자 : IN, ALL, ANY, SOME 등

- 인라인 뷰 : 테이블 명이 올 수 있는 곳에 사용, ORDER BY 사용 가능



### ```뷰``` 
- 테이블은 실제로 데이터를 가지고 있는 반면, 뷰는 실제 데이터를 가지고 있지 않다. 가상 테이블이라고도 함


### ```뷰 사용 장점```

    1. 독립성 : 테이블 구조가 변경되어도 뷰를 사용하는 응용 플그램은 변경하지 않아도 된다. 

    2. 편리성 : 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다. 

    3. 보안성 : 직원의 급여정보와 같이 숨기고 싶은 정보가 존재할 때 사용

    -뷰 생성 및 삭제
    CREATE VIEW V_PLAYER_TEAM AS
    DROP VIEW V_PLAYER_TEAM;

## ```그룹함수(중요)```

    ROLLUP - Subtotal을 생성하기 위해 사용, Grouping Columns의 수를 N이라고 했을 때 N+1 Level의 Subtotal이 생성된다. 인수 순서에 주의
    
    GROUPING - Subtotal의 total을 생성
    
    CUBE - 결합 가능한 모든 값에 대하여 다차원 집계를 생성, ROLLUP에 비해 시스템에 부하 심함
    
    GROUPING SETS - 인수들에 대한 개별 집계를 구할 
    수 있다, 다양한 소계 집합 생성 가능



### ```절차형 SQL```
- SQL문의 연속적인 실행이나 조건에 따
른 분기처리를 이용하여 특정 기능을 수행하는 저장 모듈을 생성할 수 있다 

- Procedure, User Defined 
Function, Trigger 등이 있음


### ```저장 모듈```
 - PL/SQL 문장을 DB 서버에 저장하여 사
용자와 애플리케이션 사이에서 공유할 수 있도록 만든 일종의 SQL 컴포넌트 프로그램, 독립적으로 실행되거나 다른 프로그램으로부터 실행될 수 있는 완전
한 실행 프로그램



### ```PL/SQL 특징```
1. Block 구조로 되어있어 각 기능별로 모듈화 가능
2. 변수, 상수 등을 선언하여 SQL 문장 간 값을 교환
3. IF, LOOP 등의 절차형 언어를 사용하여 절차적인 프로그램이 가능하도록 한다. 
4. DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용할 수 있다. 
5. PL/SQL은 Oracle에 내장되어 있으므로 호환성 굳
6. 응용 프로그램의 성능을 향상시킨다. 
7. Block 단위로 처리 -> 통신량을 줄일 수 있다. 


<br>

    - DECLARE : BEGIN~END 절에서 사용될 변수와 인수에 대한 정의 및 데이터 타입 선언부

    - BEGIN~END : 개발자가 처리하고자 하는 SQL문과 여러 가지 비교문, 제어문을 이용 필요한 로직 처리

    - EXCEPTION : BEGIN~END 절에서 실행되는 SQL문이 실행될 때 에러가 발생하면 그 에러를 어떻게 처리할지 정의하는 예외 처리부

    CREATE Procedure Procedure_name

    REPLACE Procedure Procedure_name

    DROP Procedure Procedure_name
        / <- 컴파일 하라는 명령어


### ```Trigger``` 
- 특정한 테이블에 INSERT, UPDATE, 
DELETE와 같은 DML문이 수행되었을 때, DB에서 자동으로 동작하도록 작성된 프로그램, ```사용자 호출이 아닌 DB 자동 수행```

- CREATE Trigger Trigger_name




### ```프로시저와 트리거의 차이점```
 - 프로시저는 BEGIN~END 절 내에 COMMIT, 
ROLLBACK과 같은 트랜잭션 종료 명령어 사용가능

 - DB 트리거는 BEGIN~END 절 내에 사용 불가



### ```NL Join(가장 기본적인 Join 기법)```
- 프로그래밍에서 사용하는 중첩된 반복문과 유사한 방식으로 조인을 수행
- 랜덤 액세스 방식으로 데이터를 읽는다.
- 먼저 읽은 테이블의 행의 수만큼 Join이 수행된다.
- ex)
        
        select 
        e.ename, d.dname
        from 
        emp e, dept d
        where
        e.deptno = d.deptno

- 순서

    1) 사원·부서 테이블을 메모리에 복사

    2) 사원 테이블에서 사원이름 꺼내서 임시 작업공간으로 가져 가져감(인덱스 상황이나 다른 요소에 따라 순서가 변경 될 수도 있음)

    3) 부서 테이블에서 해당 부서명을 찾으러 가는데 그때 위 SQL의 where조건을 보고 

        해당 조건에 맞는 데이터를 찾아서 부서명을 가져옴

    4) 한 행의 작업이 끝나면 다시 처음 테이블로 돌아가서 두번째 행의 이름을 PGA(메모리 영역으로 생각)로 가져옴

    5) 다시 부서 테이블에 가서 두번째 부서번호와 동일한 부서번호를 가진 부서명을 꺼내옴



    이와같은 과정이 먼저 읽었던 사원 테이블의 데이터가 끝이 날때까지 작업이 반복됩니다.(LOOP)


### ```Sort Merge Join```
- 조인 칼럼을 기준으로 데이터를 
정렬하여 조인을 수행
- 스캔 방식으로 데이터 읽음. 

- ex)
        
        select 
        e.ename, d.dname
        from 
        emp e, dept d
        where
        e.deptno = d.deptno

- emp 테이블의 ename의 값을 가져오고 이를 통해 dept 테이블의 dname의 값을 찾게 됩니다.이때 where 절에 있는 조건을 보고 그 조건에 맞는 dname을 가져 오게 됩니다.

즉, where절에 잘못된 조건을 줄 경우나 조건을 안 줄 경우에 올바른 데이터를 가져오지 못합니다. 

만약 dept 테이블의 데이터가 1억건 이라면 emp의 ename 값을 찾기위해 1억건을 읽어야 합니다. 

(emp 테이블에 데이터가 10개가 있다면 10억건의 데이터를 읽어야 합니다.) 그래서 join과 더불어 필수적으로 언급되는 것이 인덱스 입니다. 

인덱스가 존재한다면 해당 테이블을 전부 읽지 않고도 데이터를 찾은 후 테이블로 가서 바로 데이터를 읽을 수 있습니다. 이때 인덱스가 없을 경우에도 빨리 해당 데이터를 찾아서 결과를 출력해야 하는 경우에 Sort-Merge join 방법을 사용합니다.


출처: https://lee-mandu.tistory.com/470 [개발/일상_Mr.lee]


- 방법

    1) where 조건을 기준으로(deptno) 정렬합니다.

    2) 그리고 서로 같은 값(deptno)를 비교하여 값을 가져 옵니다.

    즉 Sort 한 후 그 결과를 Merge 해서 데이터를 찾게 됩니다.

    단점은 Sort 할 때 시간이 너무 오래 걸린다는 점 입니다.


### ```Hash Join``` 
- Hash Join은 양쪽 테이블 모두 Join 컬럼에 인덱스가 없을 경우에 사용 합니다.

- CPU 작업 위주로 처리, 해슁 기법 이
용

- NL Join의 랜덤 액세스 문제와 SMJ의 정렬 작업 부담을 해결하기 위한 대안으로 등장

- 방법

    1) 두 테이블 중에서 범위가 좁은 테이블을 메모리로 가져옵니다.

    2) Join 조건 칼럼의 데이터를 Hash 함수에 넣어서 나온 Hash Value 값으로 Hash Table을 생성합니다.

    3) 후행 테이블의 Join 조건을 Hash 함수에 넣어서 Hash Value를 생성하고 이 값을 선행 테이블의 Hash Table의 값과 비교하여 같은 값을 찾아 매칭합니다.


### ```중요```

    Sort-Merge Join과 Hash Join은 둘 다 모든 테이블을 다 읽는다는 부분은 동일하지만 Sort-Merge Join에서 실행하는 정렬은 실행하지 않습니다.

